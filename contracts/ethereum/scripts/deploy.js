const hre = require("hardhat");const fs = require("fs");const path = require("path");async function main() {  console.log("ğŸš€ Starting ULPIN Land Registry Deployment - GL-0104");  console.log("=" * 60);    // Get network info  const network = hre.network.name;  const chainId = hre.network.config.chainId;    console.log(`ğŸ“¡ Network: ${network}`);  console.log(`ğŸ”— Chain ID: ${chainId}`);    // Get deployer account  const [deployer] = await hre.ethers.getSigners();  const deployerAddress = await deployer.getAddress();  const deployerBalance = await hre.ethers.provider.getBalance(deployerAddress);    console.log(`ğŸ‘¤ Deployer: ${deployerAddress}`);  console.log(`ğŸ’° Balance: ${hre.ethers.formatEther(deployerBalance)} POL`);    // Check minimum balance (0.1 POL for deployment)  const minBalance = hre.ethers.parseEther("0.1");  if (deployerBalance < minBalance) {    throw new Error(`Insufficient balance. Need at least 0.1 POL, have ${hre.ethers.formatEther(deployerBalance)}`);  }    console.log("\nğŸ“‹ Contract Details:");  console.log("   Name: Gujarat LandChain ULPIN Registry");  console.log("   Symbol: ULPIN");  console.log("   Standard: ERC-721");  console.log("   Solidity: 0.8.20");  console.log("   OpenZeppelin: v5.0.0");    // Contract configuration  const contractName = process.env.CONTRACT_NAME || "Gujarat LandChain ULPIN Registry";  const contractSymbol = process.env.CONTRACT_SYMBOL || "ULPIN";    console.log("\nğŸ”§ Deployment Configuration:");  console.log(`   Contract Name: ${contractName}`);  console.log(`   Contract Symbol: ${contractSymbol}`);  console.log(`   Owner: ${deployerAddress}`);    // Deploy contract  console.log("\nğŸš€ Deploying Contract...");    const ULPINLandRegistry = await hre.ethers.getContractFactory("ULPINLandRegistry");  const contract = await ULPINLandRegistry.deploy(    contractName,    contractSymbol,    deployerAddress // Set deployer as initial owner  );    console.log("â³ Waiting for deployment confirmation...");    // Wait for deployment to be mined  await contract.waitForDeployment();    const contractAddress = await contract.getAddress();  const deploymentReceipt = await contract.deploymentTransaction().wait();  const gasUsed = deploymentReceipt.gasUsed;  const gasCost = gasUsed * deploymentReceipt.gasPrice;    console.log("\nâœ… Contract Deployed Successfully!");  console.log(`   ğŸ“ Address: ${contractAddress}`);  console.log(`   â›½ Gas Used: ${gasUsed.toString()}`);  console.log(`   ğŸ’° Gas Cost: ${hre.ethers.formatEther(gasCost)} POL`);  console.log(`   ğŸ§¾ Block: ${deploymentReceipt.blockNumber}`);  console.log(`   ğŸ“Š Confirmations: ${deploymentReceipt.confirmations}`);    // Verify contract ownership  const owner = await contract.owner();  console.log(`   ğŸ‘‘ Owner: ${owner}`);    // Contract verification on PolygonScan (if API key provided)  if (process.env.POLYGONSCAN_API_KEY && process.env.AUTO_VERIFY === "true") {    console.log("\nğŸ” Verifying contract on PolygonScan...");    try {      await hre.run("verify:verify", {        address: contractAddress,        constructorArguments: [contractName, contractSymbol, deployerAddress],      });      console.log("âœ… Contract verified successfully!");    } catch (error) {      console.log(`âŒ Verification failed: ${error.message}`);    }  } else {    console.log("\nâ­ï¸  Skipping verification (no API key or AUTO_VERIFY=false)");  }    // Save deployment info  const deploymentInfo = {    timestamp: new Date().toISOString(),    network: network,    chainId: chainId,    contractAddress: contractAddress,    contractName: contractName,    contractSymbol: contractSymbol,    deployerAddress: deployerAddress,    deploymentTx: deploymentReceipt.hash,    blockNumber: deploymentReceipt.blockNumber,    gasUsed: gasUsed.toString(),    gasCost: hre.ethers.formatEther(gasCost),    deploymentTime: new Date().toISOString(),    hardhatConfig: {      solidity: "0.8.20",      optimizer: true,      optimizerRuns: 200    }  };    // Create deployments directory if it doesn't exist  const deploymentsDir = path.join(__dirname, "../deployments");  if (!fs.existsSync(deploymentsDir)) {    fs.mkdirSync(deploymentsDir, { recursive: true });  }    // Save deployment info to file  const deploymentFile = path.join(deploymentsDir, `${network}-deployment.json`);  fs.writeFileSync(deploymentFile, JSON.stringify(deploymentInfo, null, 2));    console.log(`\nğŸ“ Deployment info saved to: ${deploymentFile}`);    // Display deployment summary  console.log("\n" + "ğŸ‰".repeat(50));  console.log("ğŸ¯ DEPLOYMENT COMPLETED SUCCESSFULLY! ğŸ¯");  console.log("ğŸ‰".repeat(50));  console.log(`ğŸ“ Contract Address: ${contractAddress}ğŸŒ Network: ${network} (Chain ID: ${chainId})ğŸ‘¤ Owner: ${deployerAddress}ğŸ“Š Block Number: ${deploymentReceipt.blockNumber}â›½ Gas Used: ${gasUsed.toString()}ğŸ’° Total Cost: ${hre.ethers.formatEther(gasCost)} POLğŸ”— View on PolygonScan:   https://amoy.polygonscan.com/address/${contractAddress}ğŸ“‹ Next Steps:   1. âœ… Contract is deployed and ready   2. ğŸ”— Update Julia mint agent with contract address   3. ğŸ§ª Test minting functionality   4. ğŸ“ Document deployment for Sprint 1 completionğŸ† GL-0104: Deploy to Polygon Mumbai - âœ… COMPLETED!ğŸ† Sprint 1: Gujarat LandChain Ã— JuliaOS - ğŸ¯ 100% COMPLETE!  `);    // Instructions for Julia integration  console.log("ğŸ”— Julia Integration Instructions:");  console.log(`Update your Julia script with:  CONTRACT_ADDRESS = "${contractAddress}"  NETWORK = "${network}"  CHAIN_ID = ${chainId}  RPC_URL = "${process.env.POLYGON_AMOY_RPC_URL || 'https://rpc-amoy.polygon.technology/'}"  `);    console.log("\nğŸŠ Congratulations! Your ULPIN Land Registry is now live on Polygon!");    return {    contractAddress,    deploymentTx: deploymentReceipt.hash,    network,    chainId,    gasUsed: gasUsed.toString(),    gasCost: hre.ethers.formatEther(gasCost)  };}// Handle deployment errorsmain()  .then((result) => {    console.log("\nâœ… Deployment script completed successfully!");    process.exit(0);  })  .catch((error) => {    console.error("\nâŒ Deployment failed:");    console.error(error);    process.exit(1);  });